<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Memory Allocation Visualizer — Final (Layout B, Floating Controls)</title>
<style>
:root{
  --bg:#04101a; --panel: rgba(255,255,255,0.04);
  --glass-border: rgba(255,255,255,0.06); --text:#e6eef8; --muted:#b8c2d6;
  --accent:#7c3aed; --accent-2:#06b6d4; --ok:#34d399; --active:#facc15;
  --shadow: 0 10px 30px rgba(2,6,23,0.55);
}
*{box-sizing:border-box;font-family:Inter,Segoe UI,Roboto,monospace}
html,body{height:100%;margin:0;background:linear-gradient(180deg,#04101a 0%,#07102a 60%);color:var(--text);-webkit-font-smoothing:antialiased}
.app{display:flex;gap:16px;padding:18px;height:100vh;align-items:stretch}

/* widths ~ B: left 30%, center 50%, right 20% */
.left{width:30%;display:flex;flex-direction:column;gap:12px}
.center{width:50%;display:flex;flex-direction:column;gap:12px;min-width:520px}
.right{width:20%;display:flex;flex-direction:column;gap:12px}

/* card */
.card{background:var(--panel);border-radius:12px;padding:12px;border:1px solid var(--glass-border);box-shadow:var(--shadow);overflow:auto}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.h1{font-size:16px;margin:0}
.hsub{font-size:12px;color:var(--muted)}

/* inputs */
label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
input[type="text"], input[type="number"], select, textarea{
  width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);transition:box-shadow .12s;
}
input:focus, textarea:focus{box-shadow:0 6px 18px rgba(124,58,237,0.12);outline:none}
.row{display:flex;gap:8px;align-items:center}
.col{display:flex;flex-direction:column;gap:8px}

/* control buttons style 2: square soft corners */
.ctrl-btn{
  display:inline-flex;align-items:center;justify-content:center;gap:8px;
  padding:10px 12px;border-radius:8px;border:none;background:linear-gradient(90deg,var(--accent),#9b5cff);
  color:white;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(124,58,237,0.14);transition:transform .08s,opacity .12s;
}
.ctrl-btn.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.04)}
.ctrl-btn:active{transform:translateY(1px)}
.small{padding:8px 10px;border-radius:8px;border:none;background:linear-gradient(90deg,var(--accent),#9b5cff);color:white;font-weight:600;cursor:pointer}

/* canvas */
.canvas-wrap{display:flex;flex-direction:column;gap:8px}
canvas{width:100%;height:360px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.speed{width:140px}
.pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}

/* tables */
table{width:100%;border-collapse:collapse;font-size:13px;color:var(--muted)}
th,td{padding:6px;text-align:left;border-bottom:1px dashed rgba(255,255,255,0.03)}
.icon-btn{background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted);padding:6px;border-radius:8px;cursor:pointer}

/* floating bottom bar (fade-in) */
.floating-bar{
  position:fixed;left:50%;transform:translateX(-50%);bottom:22px;
  background:rgba(255,255,255,0.06);backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.08);
  border-radius:12px;padding:10px 14px;display:flex;gap:10px;align-items:center;box-shadow:0 10px 30px rgba(2,6,23,0.6);opacity:0;pointer-events:none;transition:opacity .36s ease,transform .36s ease;
}
.floating-bar.visible{opacity:1;pointer-events:auto;transform:translateX(-50%) translateY(0);}
.ctrl-square{width:48px;height:44px;border-radius:8px;display:inline-flex;align-items:center;justify-content:center;font-size:18px;color:white;background:linear-gradient(90deg,var(--accent),#9b5cff);border:none;cursor:pointer;box-shadow:0 8px 20px rgba(2,6,23,0.45)}
.ctrl-square.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}

/* right log */
#log{white-space:pre-wrap;font-family:monospace;background:rgba(0,0,0,0.06);padding:8px;border-radius:8px;height:100%;overflow:auto;color:var(--muted)}

/* tooltips */
.tooltip{position:relative}
.tooltip:hover::after{content:attr(data-tip);position:absolute;bottom:calc(100% + 8px);left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:#fff;padding:6px 8px;border-radius:6px;font-size:12px;white-space:nowrap}

/* responsive */
@media (max-width:1100px){
  .app{flex-direction:column;padding:12px;height:auto}
  .left,.center,.right{width:100%}
  .center canvas{height:240px}
  .floating-bar{left:16px;right:16px;transform:none;bottom:12px}
}
</style>
</head>
<body>
<div class="app">
  <!-- LEFT: Memory Setup -->
  <div class="left">
    <div class="card">
      <div class="header"><div class="h1">Memory Setup</div><div class="hsub">Configure simulation</div></div>

      <label>Memory Size (KB)</label>
      <input id="memSize" type="number" value="1000" min="64">

      <label>Algorithm</label>
      <div class="row" style="gap:12px;margin-top:6px">
        <label><input type="radio" name="algo" value="first" checked> First Fit</label>
        <label><input type="radio" name="algo" value="best"> Best Fit</label>
        <label><input type="radio" name="algo" value="worst"> Worst Fit</label>
      </div>

      <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:12px 0">

      <div style="margin-bottom:6px" class="tiny">Add Process</div>
      <label>Process ID</label><input id="procId" type="text" placeholder="P1">
      <label>Size (KB)</label><input id="procSize" type="number" placeholder="200" min="1">
      <label>Arrival Time</label><input id="procArrival" type="number" value="0" min="0">

      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="addProcBtn" class="small">➕ Add</button>
        <button id="clearProcs" class="small" style="background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)">Clear</button>
      </div>

      <hr style="border:none;height:1px;background:rgba(255,255,255,0.03);margin:12px 0">

      <div style="margin-top:6px">
        <div class="tiny" style="margin-bottom:6px">Processes</div>
        <table id="procTable"><thead><tr><th>ID</th><th>Size</th><th>Arr</th><th></th></tr></thead><tbody></tbody></table>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="runBtn" class="small">▶ Generate Trace</button>
        <button id="exportPNG" class="small" style="background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)">Export PNG</button>
      </div>
    </div>
  </div>

  <!-- CENTER: Canvas always visible -->
  <div class="center">
    <div class="card canvas-wrap">
      <div class="header">
        <div>
          <div class="h1">Memory Visualization</div>
          <div class="hsub">Stepwise visualizer for First/Best/Worst Fit</div>
        </div>
        <div class="hsub">Algorithm: <span id="algoLabel">First Fit</span></div>
      </div>

      <canvas id="memCanvas" width="980" height="360"></canvas>

      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="tiny">Step: <span id="curStep">0</span>/<span id="maxStep">0</span></div>
        <div class="tiny">Utilization: <span id="util">0%</span></div>
      </div>

      <input id="timeline" type="range" min="0" max="0" value="0" style="width:100%;margin-top:8px">
    </div>

    <div style="display:flex;gap:12px">
      <div class="card" style="flex:1">
        <div class="tiny">Execution summary</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
          <div class="pill" id="summaryAlloc">Allocations: 0</div>
          <div class="pill" id="summarySteps">Steps: 0</div>
        </div>
      </div>

      <div class="card" style="width:260px">
        <div class="tiny">Export & actions</div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="exportTrace" class="small" style="background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)">Export Trace</button>
          <button id="clearAll" class="small" style="background:crimson">Clear</button>
        </div>
      </div>
    </div>
  </div>

  <!-- RIGHT: Logs -->
  <div class="right">
    <div class="card" style="display:flex;flex-direction:column;flex:1">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="h1" style="font-size:14px">Execution Logs</div>
        <div class="hsub" id="statusLabel">Idle</div>
      </div>
      <div id="log" style="margin-top:8px;flex:1;overflow:auto;font-family:monospace;color:var(--muted);padding:8px;background:rgba(0,0,0,0.06);border-radius:8px">No logs yet.</div>
    </div>

    <div class="card" style="flex:0">
      <div class="h1" style="font-size:14px">Statistics</div>
      <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
        <div>Average Waiting Time: <span id="avgWaiting" style="font-weight:600">—</span></div>
        <div>Average Turnaround: <span id="avgTurn" style="font-weight:600">—</span></div>
        <div>External Fragmentation: <span id="extFrag" style="font-weight:600">—</span></div>
        <div>Total Processes: <span id="totalProc" style="font-weight:600">0</span></div>
      </div>
    </div>
  </div>
</div>

<!-- Floating bottom bar -->
<div id="floatingBar" class="floating-bar" aria-hidden="true">
  <button id="runBtnBottom" class="ctrl-square secondary tooltip" data-tip="Generate Trace (same as left)"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M5 3v18l15-9L5 3z" fill="currentColor"/></svg></button>
  <button id="playBtn" class="ctrl-square tooltip" data-tip="Play"><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M5 3v18l15-9L5 3z" fill="currentColor"/></svg></button>
  <button id="pauseBtn" class="ctrl-square secondary tooltip" data-tip="Pause"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" fill="currentColor"/></svg></button>
  <button id="prevBtn" class="ctrl-square secondary tooltip" data-tip="Prev"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M11 18V6l-8 6 8 6zm9 0V6h-2v12h2z" fill="currentColor"/></svg></button>
  <button id="nextBtn" class="ctrl-square secondary tooltip" data-tip="Next"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M4 6v12l8-6-8-6zm9 12V6h2v12h-2z" fill="currentColor"/></svg></button>
  <button id="restartBtn" class="ctrl-square tooltip" data-tip="Restart"><svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M12 5V1L7 6l5 5V7c3.86 0 7 3.14 7 7 0 1.1-.3 2.13-.82 3.02L19.6 18A9 9 0 0012 5z" fill="currentColor"/></svg></button>
</div>

<script>
/* Renderer */
class Renderer {
  constructor(canvas){
    this.canvas = canvas;
    this.ctx = this.canvas.getContext('2d');
    this.dpr = window.devicePixelRatio || 1;
    this.resize();
    window.addEventListener('resize', ()=>this.resize());
  }
  resize(){
    const rect = this.canvas.getBoundingClientRect();
    this.canvas.width = Math.round(rect.width * this.dpr);
    this.canvas.height = Math.round(rect.height * this.dpr);
    this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0);
    if(this.last) this.render(this.last.mem, this.last.active);
  }
  clear(){ this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height); }
  render(mem, activeProcId=null){
    this.last = {mem, active: activeProcId};
    const ctx = this.ctx;
    const rect = this.canvas.getBoundingClientRect();
    const pad = 20;
    const width = rect.width - pad*2;
    const height = rect.height - pad*2;
    ctx.clearRect(0,0,rect.width,rect.height);
    ctx.save(); ctx.translate(pad,pad);
    const total = mem.size || 1;
    let x = 0;
    for(const seg of mem.segments){
      const w = Math.max(1, Math.round((seg.size/total)*width));
      if(seg.type === 'alloc'){
        const g = ctx.createLinearGradient(x,0,x+w,0); g.addColorStop(0,'#34d399'); g.addColorStop(1,'#06b6d4'); ctx.fillStyle = g;
      } else {
        const g = ctx.createLinearGradient(x,0,x+w,0); g.addColorStop(0,'#94a3b8'); g.addColorStop(1,'#475569'); ctx.fillStyle = g;
      }
      ctx.fillRect(x,0,w,height);
      ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth = 1; ctx.strokeRect(x,0,w,height);
      ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.font = '13px monospace'; ctx.textBaseline = 'top';
      const label = seg.type === 'alloc' ? `${seg.procId} (${seg.size}KB)` : `Hole (${seg.size}KB)`;
      ctx.fillText(label, x + 8, 8);
      if(activeProcId && seg.procId === activeProcId){
        ctx.save(); ctx.strokeStyle = 'rgba(250,204,21,0.95)'; ctx.lineWidth = 4; ctx.strokeRect(x-2,0,w+4,height); ctx.restore();
      }
      x += w;
    }
    ctx.restore();
  }
}

/* Utilities */
function clone(o){ return JSON.parse(JSON.stringify(o)); }
function mergeSegments(segs){
  if(!segs.length) return [];
  const sorted = segs.slice().sort((a,b)=>a.start-b.start);
  const out = [];
  for(const s of sorted){
    if(!out.length) out.push({...s});
    else{
      const last = out[out.length-1];
      if(last.type==='hole' && s.type==='hole' && last.start + last.size === s.start) last.size += s.size;
      else out.push({...s});
    }
  }
  return out;
}
function normalize(memSize, segs){
  const sorted = segs.slice().sort((a,b)=>a.start-b.start);
  const out = []; let cursor = 0;
  for(const s of sorted){
    if(s.start > cursor) out.push({start:cursor, size: s.start - cursor, type: 'hole'});
    const end = Math.min(s.start + s.size, memSize);
    out.push({...s, start: s.start, size: Math.max(0, end - s.start)});
    cursor = end;
  }
  if(cursor < memSize) out.push({start:cursor, size: memSize - cursor, type: 'hole'});
  return mergeSegments(out);
}
function findHoles(segs){ return segs.filter(s=>s.type === 'hole'); }

/* Trace generator A1 */
function generateTrace(memSize, processes, algo){
  let mem = { size: memSize, segments: [{start:0,size:memSize,type:'hole'}] };
  const procs = clone(processes).sort((a,b)=>a.arrival - b.arrival);
  const trace = [], waiting = [], finished = [];
  let t = 0;
  const push = (event, activeProc=null) => trace.push({ time: t, event, mem: clone(mem), waiting: clone(waiting), finished: clone(finished), activeProc });
  push('start', null);
  const lastArrival = procs.length ? Math.max(...procs.map(p=>p.arrival)) : 0;
  const maxTime = lastArrival + procs.length * 4 + 10;
  while(t <= maxTime){
    const arriving = procs.filter(p=>p.arrival === t);
    for(const a of arriving){ waiting.push({...a, state:'waiting'}); push(`arrive ${a.id}`, a.id); }
    let progress = true;
    while(progress){
      progress = false;
      if(!waiting.length) break;
      const holesList = findHoles(mem.segments).map(h=>({start:h.start,size:h.size,seg:h}));
      if(!holesList.length) break;
      for(let i=0;i<waiting.length;i++){
        const proc = waiting[i];
        let chosen = null;
        if(algo === 'first') chosen = holesList.find(h=>h.size >= proc.size);
        else if(algo === 'best') chosen = holesList.reduce((best,h)=> (h.size >= proc.size && (!best || h.size < best.size))?h:best, null);
        else if(algo === 'worst') chosen = holesList.reduce((worst,h)=> (h.size >= proc.size && (!worst || h.size > worst.size))?h:worst, null);
        if(chosen){
          const seg = chosen.seg; const idx = mem.segments.indexOf(seg);
          const alloc = { start: seg.start, size: proc.size, type:'alloc', procId: proc.id };
          const remain = seg.size - proc.size;
          if(remain > 0){
            const hole = { start: seg.start + proc.size, size: remain, type:'hole' };
            mem.segments.splice(idx,1,alloc,hole);
          } else mem.segments.splice(idx,1,alloc);
          mem.segments = normalize(mem.size, mem.segments);
          waiting.splice(i,1);
          finished.push({...proc, finishTime: t});
          push(`allocate ${proc.id}`, proc.id);
          progress = true;
          break;
        }
      }
    }
    if(procs.every(p=>p.arrival <= t) && waiting.length === 0){ push('done', null); break; }
    t++;
  }
  push('end', null);
  return trace;
}

/* App state */
const canvas = document.getElementById('memCanvas');
const renderer = new Renderer(canvas);
let processes = [];
let trace = [];
let step = 0;
let playing = false;
let raf = null;
let lastTime = 0;
let playAccumulator = 0;
let playInterval = 600;

/* DOM helpers */
function $(id){ return document.getElementById(id); }
const procTableBody = document.querySelector('#procTable tbody');
const logEl = $('log');

/* Render table */
function renderProcTable(){ procTableBody.innerHTML = ''; processes.forEach((p,i)=>{ const tr = document.createElement('tr'); tr.innerHTML = `<td>${p.id}</td><td>${p.size}</td><td>${p.arrival}</td><td style="text-align:right"><button data-i="${i}" class="icon-btn remove-proc">✖</button></td>`; procTableBody.appendChild(tr); }); $('totalProc').innerText = processes.length; }

/* Logging */
function addLog(txt){ const t = new Date().toLocaleTimeString(); logEl.innerText = `[${t}] ${txt}\n` + logEl.innerText; }

/* Controls wiring */
$('addProcBtn').addEventListener('click', ()=>{
  const id = $('procId').value.trim() || `P${processes.length+1}`;
  const size = parseInt($('procSize').value) || 0;
  const arrival = parseInt($('procArrival').value) || 0;
  if(!id || size <= 0){ alert('Provide valid ID and size'); return; }
  processes.push({id, size, arrival});
  renderProcTable();
  $('summaryAlloc').innerText = `Allocations: ${processes.length}`;
});
$('clearProcs').addEventListener('click', ()=>{ processes = []; renderProcTable(); $('summaryAlloc').innerText = 'Allocations: 0'; });
procTableBody.addEventListener('click', (e)=>{ if(e.target.classList.contains('remove-proc')){ processes.splice(+e.target.dataset.i,1); renderProcTable(); $('summaryAlloc').innerText = `Allocations: ${processes.length}`; } });

/* Run / generate trace */
function runGenerateTrace(){
  const memSize = parseInt($('memSize').value) || 0;
  if(memSize <= 0){ alert('Set memory size'); return; }
  if(processes.some(p=>p.size <= 0)){ alert('Ensure process sizes > 0'); return; }
  const algo = document.querySelector('input[name=algo]:checked').value;
  trace = generateTrace(memSize, processes, algo);
  step = 0;
  $('timeline').max = Math.max(0, trace.length - 1);
  $('timeline').value = 0;
  $('maxStep').innerText = trace.length - 1;
  $('log').innerText = '';
  addLog(`Generated trace (${trace.length} steps) using ${algo}`);
  updateView();
  computeStats();
  showFloatingBar();
}

/* floating bar: duplicated run button hooks */
$('runBtn').addEventListener('click', runGenerateTrace);
$('runBtnBottom').addEventListener('click', runGenerateTrace);

/* Play / Pause behavior */
$('playBtn').addEventListener('click', ()=>{
  if(!trace.length) runGenerateTrace();
  if(!trace.length) return;
  if(playing) return;
  playing = true; lastTime = performance.now(); playAccumulator = 0;
  raf = requestAnimationFrame(playLoop);
  addLog('Playback started'); $('statusLabel').innerText = 'Playing';
});
$('pauseBtn').addEventListener('click', ()=>{
  if(!playing){ $('statusLabel').innerText = 'Paused'; return; }
  playing = false; if(raf){ cancelAnimationFrame(raf); raf = null; }
  addLog('Playback paused'); $('statusLabel').innerText = 'Paused';
});
$('nextBtn').addEventListener('click', ()=> stepForward());
$('prevBtn').addEventListener('click', ()=> stepBack());
$('restartBtn').addEventListener('click', ()=>{ if(!trace.length) return; step = 0; updateView(); addLog('Restarted'); $('statusLabel').innerText = 'Restarted'; });

/* exports & clear */
$('exportPNG').addEventListener('click', ()=>{ const url = canvas.toDataURL('image/png'); const a = document.createElement('a'); a.href = url; a.download = 'memory_alloc.png'; a.click(); });
$('exportTrace').addEventListener('click', ()=>{ if(!trace.length){ alert('No trace. Run first.'); return; } const blob = new Blob([JSON.stringify(trace,null,2)],{type:'application/json'}); const u = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = u; a.download = 'trace.json'; a.click(); URL.revokeObjectURL(u); });
$('clearAll').addEventListener('click', ()=>{ if(!confirm('Clear everything?')) return; processes = []; trace = []; step = 0; renderProcTable(); updateView(); $('log').innerText = 'No logs yet.'; $('summaryAlloc').innerText = 'Allocations: 0'; $('statusLabel').innerText = 'Idle'; hideFloatingBar(); });

/* speed & timeline */
$('speed').addEventListener('input', (e)=>{ const v = parseFloat(e.target.value); $('speedLabel').innerText = v.toFixed(2) + 'x'; playInterval = 700 / v; });
$('timeline').addEventListener('input', ()=>{ step = parseInt($('timeline').value) || 0; updateView(); });

/* play loop */
function playLoop(now){
  if(!playing){ if(raf){ cancelAnimationFrame(raf); raf = null; } return; }
  raf = requestAnimationFrame(playLoop);
  if(!lastTime) lastTime = now;
  const dt = now - lastTime; lastTime = now;
  playAccumulator += dt;
  if(playAccumulator >= playInterval){
    playAccumulator = 0;
    if(step < trace.length - 1){ step++; updateView(); $('timeline').value = step; }
    else { playing = false; if(raf){ cancelAnimationFrame(raf); raf = null; } addLog('Playback finished'); $('statusLabel').innerText = 'Finished'; }
  }
}

/* step controls */
function stepForward(){ if(trace.length && step < trace.length - 1){ step++; updateView(); $('timeline').value = step; } }
function stepBack(){ if(trace.length && step > 0){ step--; updateView(); $('timeline').value = step; } }

/* update view */
function updateView(){
  if(!trace.length){ renderer.clear(); $('curStep').innerText = 0; $('maxStep').innerText = 0; $('util').innerText = '0%'; $('summarySteps').innerText = 'Steps: 0'; return; }
  const frame = trace[step];
  renderer.render(frame.mem, frame.activeProc);
  $('curStep').innerText = step; $('maxStep').innerText = trace.length - 1;
  $('statusLabel').innerText = frame.event;
  $('log').innerText = '';
  for(let i=0;i<=step;i++){ const f = trace[i]; $('log').innerText += `[t=${f.time}] ${f.event}\n`; }
  const used = frame.mem.segments.filter(s=>s.type==='alloc').reduce((s,v)=>s+v.size,0);
  const util = Math.round((used / frame.mem.size) * 100);
  $('util').innerText = util + '%';
  $('summarySteps').innerText = `Steps: ${trace.length}`;
  $('summaryAlloc').innerText = `Allocations: ${processes.length}`;
}

/* compute simple stats */
function computeStats(){
  if(!trace.length){ $('avgWaiting').innerText='—'; $('avgTurn').innerText='—'; $('extFrag').innerText='—'; $('totalProc').innerText = processes.length; return; }
  const last = trace[trace.length-1]; const finished = last.finished || [];
  const avgTurn = finished.length ? Math.round(finished.reduce((s,p)=>s + ((p.finishTime||0) - (p.arrival||0)),0) / finished.length) : 0;
  const avgWait = finished.length ? Math.round(finished.reduce((s,p)=>s + Math.max(0, ((p.finishTime||0) - (p.arrival||0) - 0)),0) / finished.length) : 0;
  const frame = trace[trace.length-1];
  const frag = frame.mem.segments.filter(s=>s.type==='hole' && s.size < 32).reduce((s,h)=>s + h.size, 0);
  $('avgWaiting').innerText = avgWait + ' (approx)';
  $('avgTurn').innerText = avgTurn + 'ms';
  $('extFrag').innerText = frag + ' KB';
  $('totalProc').innerText = processes.length;
}

/* show/hide floating bar with fade-in */
function showFloatingBar(){ const bar = $('floatingBar'); bar.classList.add('visible'); bar.setAttribute('aria-hidden','false'); }
function hideFloatingBar(){ const bar = $('floatingBar'); bar.classList.remove('visible'); bar.setAttribute('aria-hidden','true'); }

/* init demo */
renderProcTable();
(function seed(){
  processes = [{id:'P1',size:200,arrival:0},{id:'P2',size:350,arrival:1},{id:'P3',size:100,arrival:2}];
  renderProcTable(); $('summaryAlloc').innerText = `Allocations: ${processes.length}`;
})();

</script>
</body>
</html>
